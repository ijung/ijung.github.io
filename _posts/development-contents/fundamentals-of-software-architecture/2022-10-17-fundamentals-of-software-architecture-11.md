---
title: 소프트웨어 아키텍처 101 - CHAPTER 11 파이프라인 아키텍처 스타일
author: June
date: 2024-12-20 14:09:00 +0900
categories: [개발 책, 소프트웨어 아키텍처 101]
tags: [공부, 책, 소프트웨어 아키텍처 101]
toc: true
math: true
mermaid: true
comments: true
---

파이프라인 아키텍처(pipeline architecture, 파이프와 필터(pipes and filters 아키텍처라고도 함)는 소프트웨어 아키텍처에서 끊임없이 등장하는 기본적인 아키텍처 스타일입니다. 개발자와 아키텍트가 기능을 개별 파트로 분리하기로 결정하는 순간부터 이 패턴이 수반됩니다.

# 11.1 토플로지

파이프라인 아키텍처는 다수의 파이프로 필터로 구성됩니다[그림 11-1].

![스크린샷 2024-09-03 오전 8.42.46.png](/posts/development-books/fundamentals-of-software-architecture/CHAPTER11/001.png)

파이프와 필터는 특정한 방식으로 조정되며, 보통 필터 간 단방향 통신은 점대점 방식으로 구성합니다.

## 11.1.1 파이프

파이프(pipe)는 한 소스에서 입력을 받아 다른 소스로 출력을 내는, 필터 간 통신 채널입니다. 파이프는 성능상 이유로 보통 단방향, 점대점 방식으로 구성합니다. 파이프를 오가는 페이로드의 데이터는 어떤 포맷이라도 가능하지만, 아키텍트는 고성능에 유리한 적은 양의 데이터를 선호합니다.

## 11.1.2 필터

필터(filter)는 자기 완비형(self-contained)이고, 다른 필터와 독립적이며, 일반적으로 무상태성(stateless)입니다. 필터는 한 가지 태스크만 수행하므로 복합 태스크는 여러 필터를 이어붙여 처리하면 됩니다.

### 프로듀서(producer)

프로세스의 시작점입니다. 아웃바운드(outbound)만 있어서(즉, 들어오는(inbound) 트래픽은 없고 나가는(outbound) 트래픽만 있기 때문에) 소스(source)라고도 합니다.

### 변환기(transformer)

입력을 받아 필요시 일부 또는 전체 데이터를 변환한 수, 그 결과를 아웃바운드 파이프로 전달합니다. 함수형 프로그래밍의 열혈팬들은 이 기능을 맵(map)이라고 부릅니다.

### 테스터(tester)

입력을 받아 하나 이상의 기준(criteria)에  대해 테스트를 하고 그 결과에 따라 필요시 결과를 생산합니다. 함수형 프로그래머는 이 기능을 리듀스(reduce)라고 부릅니다.

### 컨슈머(consumer)

파이프라인 흐름의 종착역입니다. 컨슈머는 파이프라인 프로세스의 최종 결과를 데이터베이스에 저장하거나 유저 인터페이스 화면에 표시합니다.

### 예제

```bash
tr -cs A-Za-z ‘ \n |
tr A-Z a-z |
sort |
uniq -c |
sort -rn |
sed ${l}q
```

이 쉘 스크립트는 텍스트 데이터를 처리하여 각 단어의 빈도를 계산하고, 빈도순으로 정렬하여 상위 몇 개의 단어를 출력하는 작업을 수행합니다. 이 과정은 여러 개의 필터와 파이프를 통해 데이터를 단계별로 처리하는 파이프라인 아키텍처 스타일과 유사합니다. 각 명령어가 필터로 작동하며, 파이프(`|`)는 이 필터들을 연결하는 통신 채널 역할을 합니다. 이를 위에서 설명한 파이프와 필터 개념을 적용해 설명하면 다음과 같습니다:

1. **tr -cs 'A-Za-z' '\n'** (필터: 변환기)
    - 이 필터는 텍스트에서 알파벳 문자(A-Z, a-z)가 아닌 문자를 공백으로 변환하고, 연속된 공백을 하나의 공백으로 줄입니다. 그런 다음, 단어 단위로 텍스트를 나누어 각 단어를 새로운 줄에 위치시킵니다.
    - **역할**: 입력된 텍스트를 단어별로 구분하여 파이프라인의 다음 단계로 보낼 준비를 합니다.
2. **tr 'A-Z' 'a-z'** (필터: 변환기)
    - 이 필터는 모든 대문자를 소문자로 변환하여 대소문자 차이에 관계없이 동일한 단어로 취급되도록 합니다.
    - **역할**: 데이터를 일관된 형식(소문자)으로 변환하여 후속 필터가 쉽게 처리할 수 있도록 합니다.
3. **sort** (필터: 변환기)
    - 이 필터는 데이터를 알파벳 순으로 정렬합니다. 이 단계에서는 각 단어가 줄 단위로 나뉘어 있어, 동일한 단어들이 인접하게 정렬됩니다.
    - **역할**: 동일한 단어를 그룹화하여, 다음 단계에서 중복된 단어를 세기 쉽게 만듭니다.
4. **uniq -c** (필터: 테스터)
    - 이 필터는 연속된 중복 단어의 개수를 세어 각 단어가 텍스트에 몇 번 등장했는지 계산합니다.
    - **역할**: 각 단어의 빈도를 계산하여 데이터를 요약합니다.
5. **sort -rn** (필터: 변환기)
    - 이 필터는 단어의 빈도수를 기준으로 내림차순으로 정렬합니다.
    - **역할**: 빈도가 높은 단어가 상위에 위치하도록 데이터를 재정렬합니다.
6. **sed ${l}q** (필터: 컨슈머)
    - 이 필터는 상위 l개의 단어만 출력하고 나머지 데이터를 무시합니다.
    - **역할**: 최종 결과를 출력하여 파이프라인의 결과물을 제공합니다.

### 전체 프로세스 요약

- **프로듀서**: 입력 파일이나 텍스트 스트림.
- **변환기**: `tr` 명령어들(대소문자 변환 및 비알파벳 문자 처리), `sort` (정렬).
- **테스터**: `uniq -c` (단어 빈도 계산).
- **컨슈머**: `sed ${l}q` (결과 출력).

이 스크립트는 파이프라인 아키텍처의 원칙에 따라 각 필터(명령어)가 독립적으로 동작하며, 데이터를 단계별로 처리하여 최종적으로 상위 l개의 단어와 그 빈도를 출력하는 역할을 수행합니다.

# 11.2 예제

다양한 서비스의 텔레메트리(telemetry, 원격 계측) 정보를 아파치 카프카에 스트리밍하는 예제입니다.

![스크린샷 2024-09-04 오전 7.38.38.png](/posts/development-books/fundamentals-of-software-architecture/CHAPTER11/002.png)

- 서비스 정보처리 캡처(프로듀서) 필터는 카프카 토픽을 구독하여(subscribe) 서비스 정보를 받아 이 데이터를 지속 시간 필터라는 테스터 필터에 보내고 카프카에서 받아온 데이터가 서비스 요청 지속 시간(밀리초)과 연관되어 있는지 판단합니다.
- 지속 시간 필터는 데이터 검증 후 필요시 다음 파이프에 보내는 작업만 합니다. 만약 데이터가 서비스 요청 지속 시간(밀리초)과 관련이 있으면 지속 시간 필터는 이 데이터를 지속 시간 계산기(변환기) 필터로 전달하고, 관련이 없으면 가동 시간 필터(테스터)로 보내 데이터가 가동 시간 메트릭과 관련이 있는지 체크합니다.
- 가동 시간 메트릭과 관련이 없으면, 해당 데이터는 이 특정한 처리 흐름에 아무 쓸모가 없으므로 파이프라인은 즉시 종료됩니다. 가동 시간 메트릭과 관련이 있으면 가동 시간 계산기(변환기) 필터로 보내 해당 서비스의 가동시간 메트릭을 계산합니다.
- 두 변환기는 수정된 데이터를 데이터베이스 출력 컨슈머로 보내 몽고DB(MongoDB)에 저장합니다.

# 11.3 아키텍처 특성 등급

![스크린샷 2024-09-04 오전 7.47.32.png](/posts/development-books/fundamentals-of-software-architecture/CHAPTER11/003.png)

파이프라인 아키텍처 스타일은 애플리케이션 로직을 필터 타입(프로듀서, 테스터, 변환기, 컨슈머)에 따라 나누는, 기술 분할 아키텍처입니다. 또 파이프라인 아키텍처는 보통 모놀리식 형태로 구현/배포하므로 아키텍처 퀀텀은 언제나 1입니다.

이 아키텍처의 주요 장점은 모듈성과 결부된 전체 비용 및 단순성입니다. 이 아키텍처는 원래 모놀리식에 가깝기 때문에 분산 아키텍처 스타일에 수반되는 복잡도가 없고, 단순해서 알기 쉽고 구축 및 유지보수 비용도 비교적 적게 듭니다. 다양한 필터 타입과 변관기 간의 관심사를 분리함으로써 아키텍처 모듈성을 확보할 수 있고 필터를 교체/수정하더라도 다른 필터에는 아무런 영향도 미치지 않습니다.

# 요약

## 11.1 토폴로지

- **파이프라인 아키텍처**는 파이프와 필터로 구성되며, 필터 간 통신은 단방향, 점대점 방식으로 이루어짐.

### 11.1.1 파이프

- **파이프**는 한 소스에서 입력을 받아 다른 소스로 출력을 내는 통신 채널로, 보통 단방향 점대점 방식으로 구성됨.

### 11.1.2 필터

- **필터**는 자기 완비형, 무상태성으로, 한 가지 태스크만 수행하며 다른 필터와 독립적으로 동작함.
    - **프로듀서**: 프로세스의 시작점, 소스 역할을 수행.
    - **변환기**: 입력 데이터를 변환하여 다음 파이프로 전달.
    - **테스터**: 입력 데이터를 기준에 따라 테스트하여 필요한 경우 결과를 생성.
    - **컨슈머**: 파이프라인의 종착점으로, 최종 결과를 데이터베이스나 화면에 출력.

## 11.2 예제

- **텔레메트리 정보 스트리밍 예제**: 다양한 서비스 정보를 카프카에 스트리밍하는 과정에서 프로듀서, 테스터, 변환기, 컨슈머가 상호작용하여 데이터를 처리하고 저장함.

## 11.3 아키텍처 특성 등급

- **파이프라인 아키텍처의 장점**: 모듈성과 단순성 덕분에 비용이 낮고 유지보수가 용이하며, 필터 간의 독립성으로 인해 아키텍처가 모듈화되어 있음.
- **단점**: 모놀리식 구현 및 배포로 인한 제한이 존재.
